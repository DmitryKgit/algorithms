'''
Задача №3667. Исполнитель Водолей
У исполнителя “Водолей” есть два сосуда, первый объемом A литров,
второй объемом B литров, а также кран с водой. Водолей может
выполнять следующие операции:

Наполнить сосуд A (обозначается >A).
Наполнить сосуд B (обозначается >B).
Вылить воду из сосуда A (обозначается A>).
Вылить воду из сосуда B (обозначается B>).
Перелить воду из сосуда A в сосуд B (обозначается как A>B).
Перелить воду из сосуда B в сосуд A (обозначается как B>A).
Команда переливания из одного сосуда в другой приводят к тому,
что либо первый сосуд полностью опустошается,
либо второй сосуд полность наполняется.

Входные данные
Программа получает на вход три натуральных числа A, B, N, не превосходящих 10^4.

Выходные данные
Необходимо вывести алгоритм действий Водолея, который позволяет получить в
точности N литров в одном из сосудов, если же такого алгоритма не существует,
то программа должна вывести текст Impossible.

Количество операций в алгоритме не должно превышать 10^5.
Гарантируется, что если задача имеет решение, то есть решение,
которое содержит не более, чем 10^5 операций.

Тесты к этой задаче закрытые.

Примеры
входные данные
3
5
1
выходные данные
>A
A>B
>A
A>B
входные данные
3
5
6
выходные данные
Impossible

Две разновидности цикла while:
1) Из меньшего переливаем в большее
2) Из большего переливаем в меньшее

# Проверяем два алгоритма:
#1.Последовательные переливания из малого сосуда в большой
#2.Последовательные переливания из большого в малый
#3.Сравниваем результаты по количеству операций переливания
#4.Выводим результат алгоритма с наименьшим кол-вом переливаний

LIMIT = 10^5

Максимальное процессорное время	        0.142
Максимальный расход памяти	        27635712
Максимальное астрономическое время	0.144

100%
'''

# из меньшего в большее. Бывший однонаправленый.    
def directionUp(A, B, N, Min, Max, LIMIT):
    capA = 0 # меньшая емкость
    capB = 0 # большая емкость
    countUp = 0
    printListUp = []
    while countUp < LIMIT and capA != N and capB != N: # из меньшего в большее
        capB += A
        printListUp.append('>' + Min + '\n' + Min + '>' + Max)
        if capB > B:
            capA = capB % B
            if capA != N:
                printListUp.append(Max + '>' + '\n' + Min + '>' + Max)
                capB = capA
            countUp += 1
    return countUp, printListUp

# из большего в меньшее
def directionDwn(A, B, N, Min, Max, LIMIT):
    capA = 0 # меньшая емкость
    capB = B - A # большая емкость
    countDwn = 0
    printListDwn = ['>' + Max + '\n' + Max + '>' + Min]
    while countDwn < LIMIT and capB != N: # из большего в меньшее
        capB -= A
        printListDwn.append(Min + '>' + '\n' + Max + '>' + Min)
        if capB < 0:
            capB = B + capB
            printListDwn.append('>' + Max + '\n' + Max + '>' + Min)
        countDwn += 1
    return countDwn, printListDwn

def main():
    A = int(input())
    B = int(input())
    N = int(input())
    LIMIT = 100000
    Min = 'A'
    Max = 'B'
    if A < N and B < N: # N больше каждой из емкостей A и B
        print('Impossible')
    elif A == N:
        print('>A')
    elif B == N:
        print('>B')
    else:
        if A > B:
            Min, Max = Max, Min
            A, B = B, A
        countDwn, printListDwn = directionDwn(A, B, N, Min, Max, LIMIT)
        if countDwn == LIMIT: # ответ не найден за 10^5 шагов
            print('Impossible')
        else:
            countUp, printListUp = directionUp(A, B, N, Min, Max, LIMIT)
            if countDwn < countUp: # сравниваем количество шагов двух циклов
                print('\n'.join(printListDwn))
            else:
                print('\n'.join(printListUp))

if __name__ == '__main__':
    main()
    






