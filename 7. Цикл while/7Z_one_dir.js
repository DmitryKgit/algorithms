/*
7Z.js 04.02.2021. 
У исполнителя “Водолей” есть два сосуда, первый объемом A литров, второй объемом B литров, 
а также кран с водой. Водолей может выполнять следующие операции:

Наполнить сосуд A (обозначается >A).
Наполнить сосуд B (обозначается >B).
Вылить воду из сосуда A (обозначается A>).
Вылить воду из сосуда B (обозначается B>).
Перелить воду из сосуда A в сосуд B (обозначается как A>B).
Перелить воду из сосуда B в сосуд A (обозначается как B>A).
Команда переливания из одного сосуда в другой приводят к тому, что либо первый сосуд полностью опустошается, 
либо второй сосуд полностью наполняется.

Входные данные
Программа получает на вход три натуральных числа A, B, N, не превосходящих 104.

Выходные данные
Необходимо вывести алгоритм действий Водолея, который позволяет получить в точности N литров в одном из сосудов, 
если же такого алгоритма не существует, то программа должна вывести текст Impossible.

Количество операций в алгоритме не должно превышать 10^5. Гарантируется, что если задача имеет решение, 
то есть решение, которое содержит не более, чем 10^5 операций.

Тесты к этой задаче закрытые.

Примеры
входные данные
3
5
1
выходные данные
>A
A>B
>A
A>B
входные данные
3
5
6
выходные данные
Impossible



Алгоритм однонаправленный (всегда переливает из меньшего сосуда в больший).
Всегда наливает в меньший сосуд, затем переливает в больший, и так далее в цикле.
Сначала проходят проверки частных случаев:
    1) isLess: Если A < N && B < N, то возвращаем Impossible
    2) isEven: Если A и B чётные, а N нечётное, то возвращаем Impossible
    3) isMultiple: Если объём большего сосуда кратнен объёму меньшего сосуда, а N не кратен, то Impossible
    4) isLucky: Объём одного из сосудов оказался N
Перед выполнением выясняем, какой сосуд больше.
Перед печатью подставляем соответственные значения A и B.
*/

// объём обоих сосудов меньше N
function isLess(A, B, N) {
    return A < N && B < N;
}

// в сосудах чётное количество воды, а N - нечётное
function isEven(A, B, N) {
    return A % 2 == 0 && B % 2 == 0 && N % 2 != 0;
}

// объём большего сосуда кратнен объёму меньшего сосуда, а N не кратен
function isMultiple(A, B, N) {
    return A % B == 0 && N % B != 0 || B % A == 0 && N % A != 0;
}

// объём одного из сосудов равен N
function isLucky(A, B, N) {
    return A == N ? '>A' : B == N ? '>B' : false;
}

// всегда переливает из меньшего в больший
function fromMinToMax(Vmax, Vmin, N) {
    let max = 0;  // текущее количество воды в большем сосуде
    let min = 0;   //  текущее количество воды в меньшем сосуде
    let result = '';     
    let limit = 100000;     
    while (max != N && limit > 0) { // пока в большем сосуде не станет N, или не кончится лимит операций
        result += `>Vmin\n`;
        min = Vmin;
        limit--;
        if (max + min > Vmax) {     // объём жидкости в меньшем сосуде больше свободного объёма в большем сосуде
            result += `Vmin>Vmax\n`;
            min = max + min - Vmax;  
            limit--;
            if (min == N) {         // в меньшем сосуде оказалось N 
                return result;
            }
            result += `Vmax>\n`;
            max = 0;
            limit--;
        } 
        result += `Vmin>Vmax\n`;
        max += min;
        limit--;
    }
    return limit > 0 ? result : 'Impossible';
}

function aquarius(A, B, N) {
    if (isLess(A, B, N) || isEven(A, B, N) || isMultiple(A, B, N)) {
        return 'Impossible';
    }
    if (isLucky(A, B, N)) {
        return isLucky(A, B, N);
    }
    // проверяем, какой сосуд больше и подстанавливаем A и B в печать, даже если выводит Impossible
    return  A > B ? fromMinToMax(A, B, N).replace(/Vmax/g, 'A').replace(/Vmin/g, 'B'): 
                    fromMinToMax(B, A, N).replace(/Vmax/g, 'B').replace(/Vmin/g, 'A');
}

function autoTest() {
    console.log(aquarius(100000, 1, 99999));
}

autoTest();